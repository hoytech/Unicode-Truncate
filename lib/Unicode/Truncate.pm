package Unicode::Truncate;

our $VERSION = '0.100';

use strict;
use utf8;

use Carp;
use Encode;


use Unicode::Truncate::Inline
      C => 'DATA',
      FILTERS => [ sub { require Inline::Filters::Ragel; Inline::Filters::Ragel::ragel('-G2')->(@_) } ];


sub trunc {
  my ($input, $len, $ellipsis) = @_;

  croak "need to pass an input string to trunc" if !defined $input;
  croak "need to pass a positive truncation length to trunc" if !defined $len || $len < 0;

  $ellipsis = '…' if !defined $ellipsis;
  $ellipsis = encode('UTF-8', $ellipsis);

  $len -= length($ellipsis);

  croak "length of ellipsis is longer than truncation length";

  my ($truncation_required, $cut_len, $error_occurred) = _scan_string($input, $len);

  croak "input string not valid UTF-8 (detected at byte offset $cut_len)" if $error_occurred;

  if ($truncation_required) {
    return substr($input, 0, $cut_len) . $ellipsis;
  }

  return $input;
}



1;

__DATA__
__C__

  %%{
    machine utf8_truncator;
 
    ## Adapted from: http://www.w3.org/International/questions/qa-forms-utf-8
 
    utf8 = (0x09 | 0x0A | 0x0D | 0x20..0x7E)            | # ASCII
           (0xC2..0xDF 0x80..0xBF)                      | # non-overlong 2-byte
           (0xE0 0xA0..0xBF 0x80..0xBF)                 | # excluding overlongs
           ((0xE1..0xEC | 0xEE | 0xEF) (0x80..0xBF){2}) | # straight 3-byte
           (0xED 0x80..0x9F 0x80..0xBF)                 | # excluding surrogates
           (0xF0 0x90..0xBF (0x80..0xBF){2})            | # planes 1-3
           (0xF1..0xF3 (0x80..0xBF){3})                 | # planes 4-15
           (0xF4 0x80..0x8F (0x80..0xBF){2})              # plane 16
      ;

    ## Generated by the script in util/generate.pl

    combining = 0xCC 0x80..0xBF | 0xCD 0x80..0xAF | # Combining Diacritical Marks
                0xE1 0xAA 0xB0..0xBF | 0xE1 0xAB 0x80..0xBF | # Combining Diacritical Marks Extended
                0xE1 0xB7 0x80..0xBF | # Combining Diacritical Marks Supplement
                0xE2 0x83 0x90..0xBF | # Combining Diacritical Marks for Symbols
                0xEF 0xB8 0xA0..0xAF # Combining Half Marks
      ;

    non_combining = utf8 - combining;
 
    write data;
  }%%

  void _scan_string(SV *string, size_t trunc_size) {
    size_t cut_len = 0, last_loc = 0;
    int truncation_required = 0, error_occurred = 0;

    size_t len;
    char *start, *p, *pe, *eof;
    int cs;
 
    SvUPGRADE(string, SVt_PV);
    if (!SvPOK(string)) croak("attempting to truncate non-string object");

    len = SvCUR(string);
    start = p = SvPV(string, len);
    eof = pe = p + len;

    %%{
      main := (
                 non_combining >{ cut_len = p - start; }
               | combining
              )*
              ${
                 if (p - start >= trunc_size) {
                   truncation_required = 1;
                   goto done;
                 }
               };

      write init;
      write exec;
    }%%

    done:
 
    if (cs < utf8_truncator_first_final) error_occurred = 1;

    Inline_Stack_Vars;
    Inline_Stack_Reset;
    Inline_Stack_Push(sv_2mortal(newSViv(truncation_required)));
    Inline_Stack_Push(sv_2mortal(newSViv(cut_len)));
    Inline_Stack_Push(sv_2mortal(newSViv(error_occurred)));
    Inline_Stack_Done;
  }



__END__

=encoding utf-8

=head1 NAME

Unicode::Truncate - Unicode-aware efficient string truncation

=head1 SYNOPSIS

    my $output = trunc("hello world", 7);
    ## "hell…";

    my $output = trunc("hello world", 7, '');
    ## "hello w"

=head1 DESCRIPTION

=head1 SEE ALSO

L<Unicode-Truncate github repo|https://github.com/hoytech/Unicode-Truncate>

=head1 AUTHOR

Doug Hoyte, C<< <doug@hcsw.org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2014 Doug Hoyte.

This module is licensed under the same terms as perl itself.
